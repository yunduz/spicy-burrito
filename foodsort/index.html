<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Phaser - Making your first game, part 9</title>
  <script src="//cdn.jsdelivr.net/phaser/2.2.2/phaser.min.js"></script>
  <style type="text/css">
  body {
    margin: 0;
  }
  </style>
</head>
<body>

  <script type="text/javascript">
  var g_width = 800;
  var g_height = 600;

  var star_keys = ['pasta_small', 'butter_small', 'apple_small'];
  var permanent_star_keys = ['pasta_small', 'butter_small', 'apple_small'];
  var crate_keys = [
    'crate_smal_1year',
    'crate_smal_6months',
    'crate_smal_perishable'];

  var game = new Phaser.Game(
    g_width, g_height,
    Phaser.AUTO, '',
    { preload: preload, create: create, update: update, render: render });

  function preload() {

    game.load.image('sky', 'assets/sky.png');
    game.load.image('star', 'assets/star.png');
    game.load.image('star2', 'assets/star2.png');
    game.load.image('box', 'assets/platform.png');
    game.load.image('box2', 'assets/platform2.png');

    game.load.image('close', 'assets/orb-red.png');
    game.load.image('pb', 'assets/peanut_butter_mix.jpg');
    game.load.spritesheet('button', '/assets/button_sprite_sheet.png', 193, 71);

    //load food items
    for(var i = 0; i < star_keys.length; i++)
    {
      game.load.image(star_keys[i], 'assets/' + star_keys[i] + '.png');
    }

    //load crates
    for(var i = 0; i < star_keys.length; i++)
    {
      game.load.image(crate_keys[i], 'assets/' + crate_keys[i] + '.png');
    }

    game.load.spritesheet('conveyer', 'assets/conveyour.png', 250, 150);

  }
  var player;
  var boxes;
  var cursors;
  var stars;
  var score = 0;
  var scoreText;
  var deadline;
  var current_star_keys = [];
  var is_first_time = true;

  var button;
  var popup;
  var popup_keys = ['star', 'pb'];

  function create() {
    //  We're going to be using physics, so enable the Arcade Physics system
    game.physics.startSystem(Phaser.Physics.ARCADE);
    //  A simple background for our game
    var sky = game.add.sprite(0, 0, 'sky');
    sky.scale.setTo(2, 1.5);

    var conveyer = game.add.sprite(150, 0, 'conveyer');
    conveyer.scale.setTo(2, 2);
    var belt = conveyer.animations.add('belt');
    conveyer.animations.play('belt', 10, true);

    boxes = game.add.group();
    boxes.enableBody = true;
    for (var i = 0; i < 3; i++)
    {
      var key = crate_keys[i];
      var box = boxes.create(90+i*250, game.world.height-150, key);
      box.body.immovable = true;
    }

    deadline = game.add.sprite(0, 300, 'box');
    deadline.scale.setTo(100, 0.2);
    game.physics.arcade.enable(deadline);

    // //  Finally some stars to collect
    stars = game.add.group();
    //  We will enable physics for any star that is created in this group
    stars.enableBody = true;

    scoreText = game.add.text(16, 16, 'score: 0', { fontSize: '32px', fill: '#000' });

    game.input.onDown.add(unpause, self);

    addNewStarType();
    //add first star
    addStars();

    game.time.events.loop(Phaser.Timer.SECOND * 2, addStars, this);
    game.time.events.loop(Phaser.Timer.SECOND * 10, addNewStarType, this);
  }

  function unpause(event)
  {
    // Only act if paused
    if(game.paused)
    {
      // Calculate the corners of the menu
      var x1 = 680, x2 = 705,
      y1 = 105, y2 = 135;

      // Check if the click was inside the menu
      if(event.x > x1 && event.x < x2 && event.y > y1 && event.y < y2 )
      {
        closePopUpWindow();
      }
    }
  }

  function addNewStarType()
  {
    if(star_keys.length > 0)
    {
      //TODO: if it's the first time we're running, show instructions
      addPopUpSprite(popup_keys.pop());
      openPopUpWindow();
      current_star_keys.push(star_keys.pop());

    }
  }

  function addStars()
  {
    //  Create a star inside of the 'stars' group
    var key = current_star_keys[Math.floor(Math.random()*current_star_keys.length)];

    var star = stars.create(getRandomIntInclusive(205, 595), 0, key);

    //  Let gravity do its thing

    star.body.velocity.y = 60;

    star.checkWorldBounds = true;
    star.outOfBoundsKill = true;

    //enaable drag
    star.inputEnabled = true;
    star.input.enableDrag(false);
  }

  function addPopUpSprite(img_key)
  {
    //popup = game.add.sprite(game.world.centerX, game.world.centerY, img_key);
    popup = game.add.sprite(game.world.centerX, game.world.centerY, 'pb');
    popup.alpha = 0.8;
    popup.anchor.set(0.5);
    popup.inputEnabled = true;
    popup.visible = false;
  }

  function openPopUpWindow()
  {
    game.paused = true;
    popup.visible = true;

    //  Position the close button to the top-right of the popup sprite (minus 8px for spacing)
    var pw = (popup.width / 2) - 30;
    var ph = (popup.height / 2) - 8;

    //  And click the close button to close it down again
    var closeButton = game.make.sprite(pw, -ph, 'close');

    popup.addChild(closeButton);

    var style = { font: "32px Arial", fill: "#ff0044", wordWrap: true, wordWrapWidth: popup.width, align: "center", backgroundColor: "#ffff00" };

    text = game.add.text(0, 0, "SAMPLE TEXT", style);
    text.anchor.set(0.5);
    popup.addChild(text);

  }

  function closePopUpWindow() {
    popup.kill()
    game.paused = false;
  }

  function update() {
    game.physics.arcade.overlap(boxes, stars, collectItem, null, this);

    game.physics.arcade.overlap(deadline, stars, removeStar, null, this);
  }

  function collectItem (box, star)
  {

    // Removes the star from the screen
    star.kill();
    if((box.key === crate_keys[0] && star.key === permanent_star_keys[0]) ||
        (box.key === crate_keys[1] && star.key === permanent_star_keys[1]) ||
        (box.key === crate_keys[2] && star.key === permanent_star_keys[2]))
    {
      score += 1;
    }
    else
    {
      score -= 1;
    }
    scoreText.text = 'Score:' + score;

  }

  function removeStar(deadline, star)
  {
    if(!star.input.isDragged)
    {
      star.kill();
    }
  }

  function render()
  {
    game.debug.text("current_keys: " + current_star_keys, 20, 20);
    game.debug.pointer( game.input.activePointer );
  }

  // Returns a random integer between min (included) and max (included)
  // Using Math.round() will give you a non-uniform distribution!
  function getRandomIntInclusive(min, max)
  {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  </script>

</body>
</html>
